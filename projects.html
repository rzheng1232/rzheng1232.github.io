<!DOCTYPE html>
<html lang="en">    
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ryan | Projects</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="nav">
        <ul>
            <li><a href="index.html"><h3>Home</h3></a></li>
            <li><a href="projects.html"><h3>Projects</h3></a></li>
        </ul>
    </nav>
    <div class="header">
        <h1>Projects</h1> 
    </div>
    <div class="project-list">
        <ul>
            <li><div class="project-info">
                <h3>Boid's Algorithm Simulation</h3>
                <div class="tech">
                    <b>Languages used:</b> Python <br>
                    <b>Technologies used:</b> Pygame <br>
                    <b>Github:</b><a href="https://github.com/rzheng1232/boids"> link</a> 
                </div>
                This was a quick exploration into genetic algorithms play a role in swarming & flocking behaviors. I can't emphasize enough how amazing emergent behaviors are: by simply specifying 3 simple rules—Seperation, Alignment, and Cohesion—these complex and beautiful patterns appear. <br>
                Side note: I able to figure out multiprocessing and effective distribution of work in this project, so I was able to simulate much more particles :)
            </div><div class="project-image">
                <video controls>
                    <source src="videos/boids.mp4" type="video/mp4">
                </video>
                  
            </div></li>

            <li><div class="project-info">
                <h3>Rust Chat Server</h3>
                <div class="tech">
                    <b>Languages used:</b> Rust, SQLite <br>
                    <b>Technologies used:</b> AWS, HTTP <br>
                    <b>Github:</b><a href="https://github.com/rzheng1232/rust-chat-server.git"> server link</a>    <a href="https://github.com/rzheng1232/CS199-128-Final-Project-FA25-">app link</a>
                </div>
                I developed the server backend to a chat app as part of the final project for my CS:199:128 (Intro to Rust) course to learn more about the system design behind messaging platforms. The relatively simple chat server is written in Rust, hosted on AWS EC2, and stores user data in a SQLite database. It relies primarily on the Axum library for its web application framework and also uses Argon2 for simple password encryption. To associate users and chat groups in a clean and scalable manner, I used a bipartite graph structure, with one partition containing users, the other containing chats, and a third table storing the associations between the two. To process incoming messages with low latency and minimal synchronization overhead, I arranged them in a priority queue based on time of arrival and used multithreading with mutex locks to divide the workload. Overall, I found this to be a extremely valuable experience that taught me a great deal about designing effective and reliable systems in Rust. 
            </div><div class="project-image">
                
                <div class="image-carousel">
                    <img src="images/chatapp.png" class="nocrop">
                  
                    <button class="prev">‹</button>
                    <button class="next">›</button>
                </div>
            </div></li>

            <li><div class="project-info">
                <h3>Recyclable classifier</h3>
                <div class="tech">
                    <b>Languages used:</b> Python, Flutter, Dart, SQLite <br>
                    <b>Technologies used:</b> Flask, Tensorflow, Cloudflare Tunneling, Flutterflow, Firebase, Raspberry Pi, HTTP <br>
                    <b>Github:</b><a href="https://github.com/rzheng1232/EcoQuest-Backend"> backend link</a>
                </div>
                As part of the 2024 Congressional App Challenge, I developed the backend for an educational recycling app that enables users to take photos of objects and receive region-specific guidance on how to recycle them. The backend is a Python Flask server hosted with Waitress on a Raspberry Pi, exposed to the public via a Cloudflare tunnel. I implemented the image processing in two steps: first, a lightweight convolutional neural network classifies the image into one of several recyclable categories. Next, the classification, along with the user’s location data, is sent to a large language model (LLM) API, and the generated response is displayed to the user. The project ended up winning runner up in our region!
            </div><div class="project-image">
                
                <div class="image-carousel">
                    <video controls>
                        <source src="videos/EcoquestRecycleTool2.mp4" type="video/mp4" class="active">
                    </video>
                    <img src="images/ecoquest_workflow.png" class="nocrop">
                  
                    <button class="prev">‹</button>
                    <button class="next">›</button>
                </div>
            </div></li>

            <li><div class="project-info">
                <h3>Particle Fluid Simulation</h3>
                <div class="tech">
                    <b>Languages used:</b> Python <br>
                    <b>Technologies used:</b> Pygame, Numpy <br>
                    <b>Github:</b><a href="https://github.com/rzheng1232/simulation/tree/main/Fluid_simulation"> link</a>
                </div>
                My interest in fluid simulation primarily arose after seeing some beautiful videos by created Sebastian Lague on the topic. Although never having touched the topic before, I decided to take on this project as a challenge to complete over the summer. Initially, I read some articles on Wikipedia and various other online sources to get a better understanding of the fundemental underlying mathematics behind fluid dynamics. However, since I lacked a lot of the mathematical foundation at the time, I decided to approach this simulation with a much simpler approach; I used a Smoothed Particle Hydrodynamics method (SPH) which calculated the particle movement through the pressure/density gradient and viscosity forces. Although this wasn't the most efficient method for fluid simulation, I was still able to get a fluid-esque behavior in my particles. In the future, I would like to create an improved simulation with the Lattice-Boltzmann method.    
            </div><div class="project-image">
                <video controls>
                    <source src="videos/fluid simulation.mp4" type="video/mp4">
                </video>
            </div></li>

            <li><div class="project-info">
                <h3>Slime Mold & Ant Colony Path Optimization</h3>
                <div class="tech">
                    <b>Languages used:</b> Python <br>
                    <b>Technologies used:</b> Pygame, Numpy <br>
                    <b>Github:</b><a href="https://github.com/rzheng1232/ant-sim"> link</a>
                </div>
                I was initially introduced to the intersection between computer science and natural processes after watching the youtube channel Pezzza's Work. I was extremely fascinated by the beautiful emergent behavior that arose from simple programmed interactions between particles or objects, so I tried my hand at designing my own version of these simulations. For the most part, my experiments were successful: Using pygame for a simple visual interface, I was able to replicate the path optimization behavior of ant colonies and by slightly modifying the simulation I could similarly replicate the behavior of slime mold growth. While I was able to get the emergent behavior I was looking for, I was unfamiliar with multithreading and parallel processing, and the simulations were unfortunately single threaded, relatively small, and EXTREMELY slow. I hope to come back and improve these simualtions once I get a better understanding of simulation and multithreading. 
            </div><div class="project-image">
                <div class="image-carousel">
                    <img src="images/ant.png" class="active">
                    <img src="images/slime_mold.png" alt="Slime mold pathfinding simulation" >
                    <img src="img3.png">
                  
                    <button class="prev">‹</button>
                    <button class="next">›</button>
                </div>
            </div></li>
            
            <li><div class="project-info">
                <h3>Fractal Visualizations</h3>
                <div class="tech">
                    <b>Languages used:</b> Python <br>
                    <b>Technologies used:</b> Pygame, Numpy <br>
                    <b>Github:</b><a href="https://github.com/rzheng1232/FractalSetVisualization.git"> link</a>
                </div>
                In my Calculus BC class, we spent a day exploring topics surrounding fractals. I was immediately intrigued—particularly by the stunning images produced by iterative mathematical processes like the Mandelbrot set—so I set out to learn more about fractal visualization. I began with the Lèvy C fractal, which can be visualized using a simple iterative algorithm. For more complex fractals, I implemented the escape-time algorithm, allowing me to visualize the Mandelbrot, Julia, and Burning Ship fractals, along with many other variations. </div><div class="project-image">
                <div class="image-carousel">
                    <img src="images/levyc.png" alt="levyc" class="active">
                    <img src="images/fractal2.JPG" alt="fractal 2">
                    <img src="images/fractal3.PNG" alt="fractal 3">
                    <img src="images/fractal4.PNG" alt="fractal 4">
                    <img src="images/fractal1.png" alt="fractal 1">
                    <img src="images/burningship.png">
                  
                    <button class="prev">‹</button>
                    <button class="next">›</button>
                </div>
                
            </div></li>
            
            <li><div class="project-info">
                <h3>FIRST Robotics (Team 3984)</h3>
                <b>Languages used:</b> Java, Python <br>
                <b>Technologies used:</b> WPILib, PID & Control-Loops, Motion Profiling, OpenCV, Linux <br>
                As the lead programmer on my High School Robotics Team for 3 years, I've had the oppurtunity to both make many close friends as well as learn key technical skills in the field of Robotics. During my time on the team, I switched code framework to a command-based structure, developed reliable competition-ready code for swerve drive and the various other subsystems of the robot, and used computer vision libraries to perform relatively simple vision alignment for automated point scoring and reliable autonomous routines. Furthermore, I co-developed the data pipeline for our team's custom virtual control and telemetry dashboard for our robot using Python Flask and WPILib Libraries. Overall, since my team lacked software mentorship, I had a challenging but invigorating experience self-learning the knowledge needed to program these features and I'll always be thankful for this unique oppurtunity to reinforce my skills as a programmer. 

            </div><div class="project-image">
                <div class="image-carousel">
                    <video controls>
                        <source src="videos/Robotics.mp4" type="video/mp4">
                    </video>
                    <img src="images/robot2.jpeg">
                    <button class="prev">‹</button>
                    <button class="next">›</button>
                </div>
                
            </div></li>
            
        </ul>
    </div>
    <script>
        const carousels = document.querySelectorAll('.image-carousel');
        
        carousels.forEach(c => {
          // Select all slides: images AND videos
          const slides = Array.from(c.querySelectorAll('img, video'));
          let idx = 0;
        
          const showSlide = (i, userInitiated = false) => {
            // Hide all slides
            slides.forEach(slide => {
              slide.classList.remove('active');
              if (slide.tagName === 'VIDEO') slide.pause(); // pause videos not active
            });
        
            // Show the current slide
            slides[i].classList.add('active');
        
            // If the current slide is a video, play it
            if (userInitiated && slides[i].tagName === 'VIDEO') slides[i].play();
          };
          showSlide(idx);
          // Next button
          c.querySelector('.next').onclick = () => {
            idx = (idx + 1) % slides.length;
            showSlide(idx);
          };
        
          // Previous button
          c.querySelector('.prev').onclick = () => {
            idx = (idx - 1 + slides.length) % slides.length;
            showSlide(idx);
          };
        });
        </script>
</body>
</html>
